{"ast":null,"code":"import { focusOn } from './commands';\nimport { getTabbableNodes, contains, getFocusableNodes } from './utils/DOMutils';\nimport { asArray } from './utils/array';\n/**\n * for a given `element` in a given `scope` returns focusable siblings\n * @param element - base element\n * @param scope - common parent. Can be document, but better to narrow it down for performance reasons\n * @returns {prev,next} - references to a focusable element before and after\n * @returns undefined - if operation is not applicable\n */\n\nexport var getRelativeFocusable = function getRelativeFocusable(element, scope, useTabbables) {\n  if (!element || !scope) {\n    console.error('no element or scope given');\n    return {};\n  }\n\n  var shards = asArray(scope);\n\n  if (shards.every(function (shard) {\n    return !contains(shard, element);\n  })) {\n    console.error('Active element is not contained in the scope');\n    return {};\n  }\n\n  var focusables = useTabbables ? getTabbableNodes(shards, new Map()) : getFocusableNodes(shards, new Map());\n  var current = focusables.findIndex(function (_a) {\n    var node = _a.node;\n    return node === element;\n  });\n\n  if (current === -1) {\n    // an edge case, when anchor element is not found\n    return undefined;\n  }\n\n  return {\n    prev: focusables[current - 1],\n    next: focusables[current + 1],\n    first: focusables[0],\n    last: focusables[focusables.length - 1]\n  };\n};\n\nvar getBoundary = function getBoundary(shards, useTabbables) {\n  var set = useTabbables ? getTabbableNodes(asArray(shards), new Map()) : getFocusableNodes(asArray(shards), new Map());\n  return {\n    first: set[0],\n    last: set[set.length - 1]\n  };\n};\n\nvar defaultOptions = function defaultOptions(options) {\n  return Object.assign({\n    scope: document.body,\n    cycle: true,\n    onlyTabbable: true\n  }, options);\n};\n\nvar moveFocus = function moveFocus(fromElement, options, cb) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var newOptions = defaultOptions(options);\n  var solution = getRelativeFocusable(fromElement, newOptions.scope, newOptions.onlyTabbable);\n\n  if (!solution) {\n    return;\n  }\n\n  var target = cb(solution, newOptions.cycle);\n\n  if (target) {\n    focusOn(target.node, newOptions.focusOptions);\n  }\n};\n/**\n * focuses next element in the tab-order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\n\n\nexport var focusNextElement = function focusNextElement(fromElement, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  moveFocus(fromElement, options, function (_a, cycle) {\n    var next = _a.next,\n        first = _a.first;\n    return next || cycle && first;\n  });\n};\n/**\n * focuses prev element in the tab order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\n\nexport var focusPrevElement = function focusPrevElement(fromElement, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  moveFocus(fromElement, options, function (_a, cycle) {\n    var prev = _a.prev,\n        last = _a.last;\n    return prev || cycle && last;\n  });\n};\n\nvar pickBoundary = function pickBoundary(scope, options, what) {\n  var _a;\n\n  var boundary = getBoundary(scope, (_a = options.onlyTabbable) !== null && _a !== void 0 ? _a : true);\n  var node = boundary[what];\n\n  if (node) {\n    focusOn(node.node, options.focusOptions);\n  }\n};\n/**\n * focuses first element in the tab-order\n * @param {FocusNextOptions} options - focus options\n */\n\n\nexport var focusFirstElement = function focusFirstElement(scope, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  pickBoundary(scope, options, 'first');\n};\n/**\n * focuses last element in the tab order\n * @param {FocusNextOptions} options - focus options\n */\n\nexport var focusLastElement = function focusLastElement(scope, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  pickBoundary(scope, options, 'last');\n};","map":{"version":3,"names":["focusOn","getTabbableNodes","contains","getFocusableNodes","asArray","getRelativeFocusable","element","scope","useTabbables","console","error","shards","every","shard","focusables","Map","current","findIndex","_a","node","undefined","prev","next","first","last","length","getBoundary","set","defaultOptions","options","Object","assign","document","body","cycle","onlyTabbable","moveFocus","fromElement","cb","newOptions","solution","target","focusOptions","focusNextElement","focusPrevElement","pickBoundary","what","boundary","focusFirstElement","focusLastElement"],"sources":["/workspaces/200508238/develop/node_modules/@chakra-ui/react/node_modules/focus-lock/dist/es2015/sibling.js"],"sourcesContent":["import { focusOn } from './commands';\nimport { getTabbableNodes, contains, getFocusableNodes } from './utils/DOMutils';\nimport { asArray } from './utils/array';\n/**\n * for a given `element` in a given `scope` returns focusable siblings\n * @param element - base element\n * @param scope - common parent. Can be document, but better to narrow it down for performance reasons\n * @returns {prev,next} - references to a focusable element before and after\n * @returns undefined - if operation is not applicable\n */\nexport var getRelativeFocusable = function (element, scope, useTabbables) {\n    if (!element || !scope) {\n        console.error('no element or scope given');\n        return {};\n    }\n    var shards = asArray(scope);\n    if (shards.every(function (shard) { return !contains(shard, element); })) {\n        console.error('Active element is not contained in the scope');\n        return {};\n    }\n    var focusables = useTabbables\n        ? getTabbableNodes(shards, new Map())\n        : getFocusableNodes(shards, new Map());\n    var current = focusables.findIndex(function (_a) {\n        var node = _a.node;\n        return node === element;\n    });\n    if (current === -1) {\n        // an edge case, when anchor element is not found\n        return undefined;\n    }\n    return {\n        prev: focusables[current - 1],\n        next: focusables[current + 1],\n        first: focusables[0],\n        last: focusables[focusables.length - 1],\n    };\n};\nvar getBoundary = function (shards, useTabbables) {\n    var set = useTabbables\n        ? getTabbableNodes(asArray(shards), new Map())\n        : getFocusableNodes(asArray(shards), new Map());\n    return {\n        first: set[0],\n        last: set[set.length - 1],\n    };\n};\nvar defaultOptions = function (options) {\n    return Object.assign({\n        scope: document.body,\n        cycle: true,\n        onlyTabbable: true,\n    }, options);\n};\nvar moveFocus = function (fromElement, options, cb) {\n    if (options === void 0) { options = {}; }\n    var newOptions = defaultOptions(options);\n    var solution = getRelativeFocusable(fromElement, newOptions.scope, newOptions.onlyTabbable);\n    if (!solution) {\n        return;\n    }\n    var target = cb(solution, newOptions.cycle);\n    if (target) {\n        focusOn(target.node, newOptions.focusOptions);\n    }\n};\n/**\n * focuses next element in the tab-order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\nexport var focusNextElement = function (fromElement, options) {\n    if (options === void 0) { options = {}; }\n    moveFocus(fromElement, options, function (_a, cycle) {\n        var next = _a.next, first = _a.first;\n        return next || (cycle && first);\n    });\n};\n/**\n * focuses prev element in the tab order\n * @param fromElement - common parent to scope active element search or tab cycle order\n * @param {FocusNextOptions} [options] - focus options\n */\nexport var focusPrevElement = function (fromElement, options) {\n    if (options === void 0) { options = {}; }\n    moveFocus(fromElement, options, function (_a, cycle) {\n        var prev = _a.prev, last = _a.last;\n        return prev || (cycle && last);\n    });\n};\nvar pickBoundary = function (scope, options, what) {\n    var _a;\n    var boundary = getBoundary(scope, (_a = options.onlyTabbable) !== null && _a !== void 0 ? _a : true);\n    var node = boundary[what];\n    if (node) {\n        focusOn(node.node, options.focusOptions);\n    }\n};\n/**\n * focuses first element in the tab-order\n * @param {FocusNextOptions} options - focus options\n */\nexport var focusFirstElement = function (scope, options) {\n    if (options === void 0) { options = {}; }\n    pickBoundary(scope, options, 'first');\n};\n/**\n * focuses last element in the tab order\n * @param {FocusNextOptions} options - focus options\n */\nexport var focusLastElement = function (scope, options) {\n    if (options === void 0) { options = {}; }\n    pickBoundary(scope, options, 'last');\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}