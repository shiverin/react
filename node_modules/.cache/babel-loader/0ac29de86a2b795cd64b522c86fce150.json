{"ast":null,"code":"import _toConsumableArray from \"/workspaces/200508238/develop/node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { color } from '../color/index.mjs';\nimport { number } from '../numbers/index.mjs';\nimport { isString, floatRegex, colorRegex, sanitize } from '../utils.mjs';\nvar colorToken = \"${c}\";\nvar numberToken = \"${n}\";\n\nfunction test(v) {\n  var _a, _b;\n\n  return isNaN(v) && isString(v) && (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;\n}\n\nfunction analyseComplexValue(v) {\n  if (typeof v === \"number\") v = \"\".concat(v);\n  var values = [];\n  var numColors = 0;\n  var numNumbers = 0;\n  var colors = v.match(colorRegex);\n\n  if (colors) {\n    numColors = colors.length; // Strip colors from input so they're not picked up by number regex.\n    // There's a better way to combine these regex searches, but its beyond my regex skills\n\n    v = v.replace(colorRegex, colorToken);\n    values.push.apply(values, _toConsumableArray(colors.map(color.parse)));\n  }\n\n  var numbers = v.match(floatRegex);\n\n  if (numbers) {\n    numNumbers = numbers.length;\n    v = v.replace(floatRegex, numberToken);\n    values.push.apply(values, _toConsumableArray(numbers.map(number.parse)));\n  }\n\n  return {\n    values: values,\n    numColors: numColors,\n    numNumbers: numNumbers,\n    tokenised: v\n  };\n}\n\nfunction parse(v) {\n  return analyseComplexValue(v).values;\n}\n\nfunction createTransformer(source) {\n  var _analyseComplexValue = analyseComplexValue(source),\n      values = _analyseComplexValue.values,\n      numColors = _analyseComplexValue.numColors,\n      tokenised = _analyseComplexValue.tokenised;\n\n  var numValues = values.length;\n  return function (v) {\n    var output = tokenised;\n\n    for (var i = 0; i < numValues; i++) {\n      output = output.replace(i < numColors ? colorToken : numberToken, i < numColors ? color.transform(v[i]) : sanitize(v[i]));\n    }\n\n    return output;\n  };\n}\n\nvar convertNumbersToZero = function convertNumbersToZero(v) {\n  return typeof v === \"number\" ? 0 : v;\n};\n\nfunction getAnimatableNone(v) {\n  var parsed = parse(v);\n  var transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\n\nvar complex = {\n  test: test,\n  parse: parse,\n  createTransformer: createTransformer,\n  getAnimatableNone: getAnimatableNone\n};\nexport { analyseComplexValue, complex };","map":{"version":3,"names":["color","number","isString","floatRegex","colorRegex","sanitize","colorToken","numberToken","test","v","_a","_b","isNaN","match","length","analyseComplexValue","values","numColors","numNumbers","colors","replace","push","map","parse","numbers","tokenised","createTransformer","source","numValues","output","i","transform","convertNumbersToZero","getAnimatableNone","parsed","transformer","complex"],"sources":["/workspaces/200508238/develop/node_modules/framer-motion/dist/es/value/types/complex/index.mjs"],"sourcesContent":["import { color } from '../color/index.mjs';\nimport { number } from '../numbers/index.mjs';\nimport { isString, floatRegex, colorRegex, sanitize } from '../utils.mjs';\n\nconst colorToken = \"${c}\";\nconst numberToken = \"${n}\";\nfunction test(v) {\n    var _a, _b;\n    return (isNaN(v) &&\n        isString(v) &&\n        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +\n            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >\n            0);\n}\nfunction analyseComplexValue(v) {\n    if (typeof v === \"number\")\n        v = `${v}`;\n    const values = [];\n    let numColors = 0;\n    let numNumbers = 0;\n    const colors = v.match(colorRegex);\n    if (colors) {\n        numColors = colors.length;\n        // Strip colors from input so they're not picked up by number regex.\n        // There's a better way to combine these regex searches, but its beyond my regex skills\n        v = v.replace(colorRegex, colorToken);\n        values.push(...colors.map(color.parse));\n    }\n    const numbers = v.match(floatRegex);\n    if (numbers) {\n        numNumbers = numbers.length;\n        v = v.replace(floatRegex, numberToken);\n        values.push(...numbers.map(number.parse));\n    }\n    return { values, numColors, numNumbers, tokenised: v };\n}\nfunction parse(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { values, numColors, tokenised } = analyseComplexValue(source);\n    const numValues = values.length;\n    return (v) => {\n        let output = tokenised;\n        for (let i = 0; i < numValues; i++) {\n            output = output.replace(i < numColors ? colorToken : numberToken, i < numColors\n                ? color.transform(v[i])\n                : sanitize(v[i]));\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone(v) {\n    const parsed = parse(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = { test, parse, createTransformer, getAnimatableNone };\n\nexport { analyseComplexValue, complex };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}