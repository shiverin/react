{"ast":null,"code":"import { calcGeneratorVelocity, pregenerateKeyframes } from '@motionone/generators';\nimport { isNumber, isString, noopReturn } from '@motionone/utils';\nimport { getUnitConverter } from '../animate/utils/get-unit.es.js';\nimport { transformDefinitions } from '../animate/utils/transforms.es.js';\nimport { getStyleName } from '../animate/utils/get-style-name.es.js';\n\nfunction canGenerate(value) {\n  return isNumber(value) && !isNaN(value);\n}\n\nfunction getAsNumber(value) {\n  return isString(value) ? parseFloat(value) : value;\n}\n\nfunction createGeneratorEasing(createGenerator) {\n  var keyframesCache = new WeakMap();\n  return function () {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var generatorCache = new Map();\n\n    var getGenerator = function getGenerator() {\n      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n      var velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var isScale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var key = \"\".concat(from, \"-\").concat(to, \"-\").concat(velocity, \"-\").concat(isScale);\n\n      if (!generatorCache.has(key)) {\n        generatorCache.set(key, createGenerator(Object.assign({\n          from: from,\n          to: to,\n          velocity: velocity\n        }, options)));\n      }\n\n      return generatorCache.get(key);\n    };\n\n    var getKeyframes = function getKeyframes(generator, toUnit) {\n      if (!keyframesCache.has(generator)) {\n        keyframesCache.set(generator, pregenerateKeyframes(generator, toUnit));\n      }\n\n      return keyframesCache.get(generator);\n    };\n\n    return {\n      createAnimation: function createAnimation(keyframes) {\n        var shouldGenerate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var getOrigin = arguments.length > 2 ? arguments[2] : undefined;\n        var name = arguments.length > 3 ? arguments[3] : undefined;\n        var motionValue = arguments.length > 4 ? arguments[4] : undefined;\n        var settings;\n        var origin;\n        var target;\n        var velocity = 0;\n        var toUnit = noopReturn;\n        var numKeyframes = keyframes.length;\n        /**\n         * If we should generate an animation for this value, run some preperation\n         * like resolving target/origin, finding a unit (if any) and determine if\n         * it is actually possible to generate.\n         */\n\n        if (shouldGenerate) {\n          toUnit = getUnitConverter(keyframes, name ? transformDefinitions.get(getStyleName(name)) : undefined);\n          var targetDefinition = keyframes[numKeyframes - 1];\n          target = getAsNumber(targetDefinition);\n\n          if (numKeyframes > 1 && keyframes[0] !== null) {\n            /**\n             * If we have multiple keyframes, take the initial keyframe as the origin.\n             */\n            origin = getAsNumber(keyframes[0]);\n          } else {\n            var prevGenerator = motionValue === null || motionValue === void 0 ? void 0 : motionValue.generator;\n            /**\n             * If we have an existing generator for this value we can use it to resolve\n             * the animation's current value and velocity.\n             */\n\n            if (prevGenerator) {\n              /**\n               * If we have a generator for this value we can use it to resolve\n               * the animations's current value and velocity.\n               */\n              var animation = motionValue.animation,\n                  generatorStartTime = motionValue.generatorStartTime;\n              var startTime = (animation === null || animation === void 0 ? void 0 : animation.startTime) || generatorStartTime || 0;\n              var currentTime = (animation === null || animation === void 0 ? void 0 : animation.currentTime) || performance.now() - startTime;\n              var prevGeneratorCurrent = prevGenerator(currentTime).current;\n              origin = prevGeneratorCurrent;\n              velocity = calcGeneratorVelocity(function (t) {\n                return prevGenerator(t).current;\n              }, currentTime, prevGeneratorCurrent);\n            } else if (getOrigin) {\n              /**\n               * As a last resort, read the origin from the DOM.\n               */\n              origin = getAsNumber(getOrigin());\n            }\n          }\n        }\n        /**\n         * If we've determined it is possible to generate an animation, do so.\n         */\n\n\n        if (canGenerate(origin) && canGenerate(target)) {\n          var generator = getGenerator(origin, target, velocity, name === null || name === void 0 ? void 0 : name.includes(\"scale\"));\n          settings = Object.assign(Object.assign({}, getKeyframes(generator, toUnit)), {\n            easing: \"linear\"\n          }); // TODO Add test for this\n\n          if (motionValue) {\n            motionValue.generator = generator;\n            motionValue.generatorStartTime = performance.now();\n          }\n        }\n        /**\n         * If by now we haven't generated a set of keyframes, create a generic generator\n         * based on the provided props that animates from 0-100 to fetch a rough\n         * \"overshootDuration\" - the moment when the generator first hits the animation target.\n         * Then return animation settings that will run a normal animation for that duration.\n         */\n\n\n        if (!settings) {\n          var keyframesMetadata = getKeyframes(getGenerator(0, 100));\n          settings = {\n            easing: \"ease\",\n            duration: keyframesMetadata.overshootDuration\n          };\n        }\n\n        return settings;\n      }\n    };\n  };\n}\n\nexport { createGeneratorEasing };","map":{"version":3,"names":["calcGeneratorVelocity","pregenerateKeyframes","isNumber","isString","noopReturn","getUnitConverter","transformDefinitions","getStyleName","canGenerate","value","isNaN","getAsNumber","parseFloat","createGeneratorEasing","createGenerator","keyframesCache","WeakMap","options","generatorCache","Map","getGenerator","from","to","velocity","isScale","key","has","set","Object","assign","get","getKeyframes","generator","toUnit","createAnimation","keyframes","shouldGenerate","getOrigin","name","motionValue","settings","origin","target","numKeyframes","length","undefined","targetDefinition","prevGenerator","animation","generatorStartTime","startTime","currentTime","performance","now","prevGeneratorCurrent","current","t","includes","easing","keyframesMetadata","duration","overshootDuration"],"sources":["/workspaces/200508238/develop/node_modules/framer-motion/node_modules/@motionone/dom/dist/easing/create-generator-easing.es.js"],"sourcesContent":["import { calcGeneratorVelocity, pregenerateKeyframes } from '@motionone/generators';\nimport { isNumber, isString, noopReturn } from '@motionone/utils';\nimport { getUnitConverter } from '../animate/utils/get-unit.es.js';\nimport { transformDefinitions } from '../animate/utils/transforms.es.js';\nimport { getStyleName } from '../animate/utils/get-style-name.es.js';\n\nfunction canGenerate(value) {\n    return isNumber(value) && !isNaN(value);\n}\nfunction getAsNumber(value) {\n    return isString(value) ? parseFloat(value) : value;\n}\nfunction createGeneratorEasing(createGenerator) {\n    const keyframesCache = new WeakMap();\n    return (options = {}) => {\n        const generatorCache = new Map();\n        const getGenerator = (from = 0, to = 100, velocity = 0, isScale = false) => {\n            const key = `${from}-${to}-${velocity}-${isScale}`;\n            if (!generatorCache.has(key)) {\n                generatorCache.set(key, createGenerator(Object.assign({ from,\n                    to,\n                    velocity }, options)));\n            }\n            return generatorCache.get(key);\n        };\n        const getKeyframes = (generator, toUnit) => {\n            if (!keyframesCache.has(generator)) {\n                keyframesCache.set(generator, pregenerateKeyframes(generator, toUnit));\n            }\n            return keyframesCache.get(generator);\n        };\n        return {\n            createAnimation: (keyframes, shouldGenerate = true, getOrigin, name, motionValue) => {\n                let settings;\n                let origin;\n                let target;\n                let velocity = 0;\n                let toUnit = noopReturn;\n                const numKeyframes = keyframes.length;\n                /**\n                 * If we should generate an animation for this value, run some preperation\n                 * like resolving target/origin, finding a unit (if any) and determine if\n                 * it is actually possible to generate.\n                 */\n                if (shouldGenerate) {\n                    toUnit = getUnitConverter(keyframes, name ? transformDefinitions.get(getStyleName(name)) : undefined);\n                    const targetDefinition = keyframes[numKeyframes - 1];\n                    target = getAsNumber(targetDefinition);\n                    if (numKeyframes > 1 && keyframes[0] !== null) {\n                        /**\n                         * If we have multiple keyframes, take the initial keyframe as the origin.\n                         */\n                        origin = getAsNumber(keyframes[0]);\n                    }\n                    else {\n                        const prevGenerator = motionValue === null || motionValue === void 0 ? void 0 : motionValue.generator;\n                        /**\n                         * If we have an existing generator for this value we can use it to resolve\n                         * the animation's current value and velocity.\n                         */\n                        if (prevGenerator) {\n                            /**\n                             * If we have a generator for this value we can use it to resolve\n                             * the animations's current value and velocity.\n                             */\n                            const { animation, generatorStartTime } = motionValue;\n                            const startTime = (animation === null || animation === void 0 ? void 0 : animation.startTime) || generatorStartTime || 0;\n                            const currentTime = (animation === null || animation === void 0 ? void 0 : animation.currentTime) || performance.now() - startTime;\n                            const prevGeneratorCurrent = prevGenerator(currentTime).current;\n                            origin = prevGeneratorCurrent;\n                            velocity = calcGeneratorVelocity((t) => prevGenerator(t).current, currentTime, prevGeneratorCurrent);\n                        }\n                        else if (getOrigin) {\n                            /**\n                             * As a last resort, read the origin from the DOM.\n                             */\n                            origin = getAsNumber(getOrigin());\n                        }\n                    }\n                }\n                /**\n                 * If we've determined it is possible to generate an animation, do so.\n                 */\n                if (canGenerate(origin) && canGenerate(target)) {\n                    const generator = getGenerator(origin, target, velocity, name === null || name === void 0 ? void 0 : name.includes(\"scale\"));\n                    settings = Object.assign(Object.assign({}, getKeyframes(generator, toUnit)), { easing: \"linear\" });\n                    // TODO Add test for this\n                    if (motionValue) {\n                        motionValue.generator = generator;\n                        motionValue.generatorStartTime = performance.now();\n                    }\n                }\n                /**\n                 * If by now we haven't generated a set of keyframes, create a generic generator\n                 * based on the provided props that animates from 0-100 to fetch a rough\n                 * \"overshootDuration\" - the moment when the generator first hits the animation target.\n                 * Then return animation settings that will run a normal animation for that duration.\n                 */\n                if (!settings) {\n                    const keyframesMetadata = getKeyframes(getGenerator(0, 100));\n                    settings = {\n                        easing: \"ease\",\n                        duration: keyframesMetadata.overshootDuration,\n                    };\n                }\n                return settings;\n            },\n        };\n    };\n}\n\nexport { createGeneratorEasing };\n"],"mappings":"AAAA,SAASA,qBAAT,EAAgCC,oBAAhC,QAA4D,uBAA5D;AACA,SAASC,QAAT,EAAmBC,QAAnB,EAA6BC,UAA7B,QAA+C,kBAA/C;AACA,SAASC,gBAAT,QAAiC,iCAAjC;AACA,SAASC,oBAAT,QAAqC,mCAArC;AACA,SAASC,YAAT,QAA6B,uCAA7B;;AAEA,SAASC,WAAT,CAAqBC,KAArB,EAA4B;EACxB,OAAOP,QAAQ,CAACO,KAAD,CAAR,IAAmB,CAACC,KAAK,CAACD,KAAD,CAAhC;AACH;;AACD,SAASE,WAAT,CAAqBF,KAArB,EAA4B;EACxB,OAAON,QAAQ,CAACM,KAAD,CAAR,GAAkBG,UAAU,CAACH,KAAD,CAA5B,GAAsCA,KAA7C;AACH;;AACD,SAASI,qBAAT,CAA+BC,eAA/B,EAAgD;EAC5C,IAAMC,cAAc,GAAG,IAAIC,OAAJ,EAAvB;EACA,OAAO,YAAkB;IAAA,IAAjBC,OAAiB,uEAAP,EAAO;IACrB,IAAMC,cAAc,GAAG,IAAIC,GAAJ,EAAvB;;IACA,IAAMC,YAAY,GAAG,SAAfA,YAAe,GAAuD;MAAA,IAAtDC,IAAsD,uEAA/C,CAA+C;MAAA,IAA5CC,EAA4C,uEAAvC,GAAuC;MAAA,IAAlCC,QAAkC,uEAAvB,CAAuB;MAAA,IAApBC,OAAoB,uEAAV,KAAU;MACxE,IAAMC,GAAG,aAAMJ,IAAN,cAAcC,EAAd,cAAoBC,QAApB,cAAgCC,OAAhC,CAAT;;MACA,IAAI,CAACN,cAAc,CAACQ,GAAf,CAAmBD,GAAnB,CAAL,EAA8B;QAC1BP,cAAc,CAACS,GAAf,CAAmBF,GAAnB,EAAwBX,eAAe,CAACc,MAAM,CAACC,MAAP,CAAc;UAAER,IAAI,EAAJA,IAAF;UAClDC,EAAE,EAAFA,EADkD;UAElDC,QAAQ,EAARA;QAFkD,CAAd,EAExBN,OAFwB,CAAD,CAAvC;MAGH;;MACD,OAAOC,cAAc,CAACY,GAAf,CAAmBL,GAAnB,CAAP;IACH,CARD;;IASA,IAAMM,YAAY,GAAG,SAAfA,YAAe,CAACC,SAAD,EAAYC,MAAZ,EAAuB;MACxC,IAAI,CAAClB,cAAc,CAACW,GAAf,CAAmBM,SAAnB,CAAL,EAAoC;QAChCjB,cAAc,CAACY,GAAf,CAAmBK,SAAnB,EAA8B/B,oBAAoB,CAAC+B,SAAD,EAAYC,MAAZ,CAAlD;MACH;;MACD,OAAOlB,cAAc,CAACe,GAAf,CAAmBE,SAAnB,CAAP;IACH,CALD;;IAMA,OAAO;MACHE,eAAe,EAAE,yBAACC,SAAD,EAAoE;QAAA,IAAxDC,cAAwD,uEAAvC,IAAuC;QAAA,IAAjCC,SAAiC;QAAA,IAAtBC,IAAsB;QAAA,IAAhBC,WAAgB;QACjF,IAAIC,QAAJ;QACA,IAAIC,MAAJ;QACA,IAAIC,MAAJ;QACA,IAAInB,QAAQ,GAAG,CAAf;QACA,IAAIU,MAAM,GAAG7B,UAAb;QACA,IAAMuC,YAAY,GAAGR,SAAS,CAACS,MAA/B;QACA;AAChB;AACA;AACA;AACA;;QACgB,IAAIR,cAAJ,EAAoB;UAChBH,MAAM,GAAG5B,gBAAgB,CAAC8B,SAAD,EAAYG,IAAI,GAAGhC,oBAAoB,CAACwB,GAArB,CAAyBvB,YAAY,CAAC+B,IAAD,CAArC,CAAH,GAAkDO,SAAlE,CAAzB;UACA,IAAMC,gBAAgB,GAAGX,SAAS,CAACQ,YAAY,GAAG,CAAhB,CAAlC;UACAD,MAAM,GAAG/B,WAAW,CAACmC,gBAAD,CAApB;;UACA,IAAIH,YAAY,GAAG,CAAf,IAAoBR,SAAS,CAAC,CAAD,CAAT,KAAiB,IAAzC,EAA+C;YAC3C;AACxB;AACA;YACwBM,MAAM,GAAG9B,WAAW,CAACwB,SAAS,CAAC,CAAD,CAAV,CAApB;UACH,CALD,MAMK;YACD,IAAMY,aAAa,GAAGR,WAAW,KAAK,IAAhB,IAAwBA,WAAW,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,WAAW,CAACP,SAA5F;YACA;AACxB;AACA;AACA;;YACwB,IAAIe,aAAJ,EAAmB;cACf;AAC5B;AACA;AACA;cAC4B,IAAQC,SAAR,GAA0CT,WAA1C,CAAQS,SAAR;cAAA,IAAmBC,kBAAnB,GAA0CV,WAA1C,CAAmBU,kBAAnB;cACA,IAAMC,SAAS,GAAG,CAACF,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,SAAS,CAACE,SAAjE,KAA+ED,kBAA/E,IAAqG,CAAvH;cACA,IAAME,WAAW,GAAG,CAACH,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,SAAS,CAACG,WAAjE,KAAiFC,WAAW,CAACC,GAAZ,KAAoBH,SAAzH;cACA,IAAMI,oBAAoB,GAAGP,aAAa,CAACI,WAAD,CAAb,CAA2BI,OAAxD;cACAd,MAAM,GAAGa,oBAAT;cACA/B,QAAQ,GAAGvB,qBAAqB,CAAC,UAACwD,CAAD;gBAAA,OAAOT,aAAa,CAACS,CAAD,CAAb,CAAiBD,OAAxB;cAAA,CAAD,EAAkCJ,WAAlC,EAA+CG,oBAA/C,CAAhC;YACH,CAXD,MAYK,IAAIjB,SAAJ,EAAe;cAChB;AAC5B;AACA;cAC4BI,MAAM,GAAG9B,WAAW,CAAC0B,SAAS,EAAV,CAApB;YACH;UACJ;QACJ;QACD;AAChB;AACA;;;QACgB,IAAI7B,WAAW,CAACiC,MAAD,CAAX,IAAuBjC,WAAW,CAACkC,MAAD,CAAtC,EAAgD;UAC5C,IAAMV,SAAS,GAAGZ,YAAY,CAACqB,MAAD,EAASC,MAAT,EAAiBnB,QAAjB,EAA2Be,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,KAAK,CAA/B,GAAmC,KAAK,CAAxC,GAA4CA,IAAI,CAACmB,QAAL,CAAc,OAAd,CAAvE,CAA9B;UACAjB,QAAQ,GAAGZ,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBE,YAAY,CAACC,SAAD,EAAYC,MAAZ,CAA9B,CAAd,EAAkE;YAAEyB,MAAM,EAAE;UAAV,CAAlE,CAAX,CAF4C,CAG5C;;UACA,IAAInB,WAAJ,EAAiB;YACbA,WAAW,CAACP,SAAZ,GAAwBA,SAAxB;YACAO,WAAW,CAACU,kBAAZ,GAAiCG,WAAW,CAACC,GAAZ,EAAjC;UACH;QACJ;QACD;AAChB;AACA;AACA;AACA;AACA;;;QACgB,IAAI,CAACb,QAAL,EAAe;UACX,IAAMmB,iBAAiB,GAAG5B,YAAY,CAACX,YAAY,CAAC,CAAD,EAAI,GAAJ,CAAb,CAAtC;UACAoB,QAAQ,GAAG;YACPkB,MAAM,EAAE,MADD;YAEPE,QAAQ,EAAED,iBAAiB,CAACE;UAFrB,CAAX;QAIH;;QACD,OAAOrB,QAAP;MACH;IA3EE,CAAP;EA6EH,CA9FD;AA+FH;;AAED,SAAS3B,qBAAT"},"metadata":{},"sourceType":"module"}