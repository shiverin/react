{"ast":null,"code":"import { NEW_FOCUS, newFocus } from './solver';\nimport { getFocusableNodes } from './utils/DOMutils';\nimport { getAllAffectedNodes } from './utils/all-affected';\nimport { asArray, getFirst } from './utils/array';\nimport { pickAutofocus } from './utils/auto-focus';\nimport { getActiveElement } from './utils/getActiveElement';\nimport { isDefined, isNotAGuard } from './utils/is';\nimport { allParentAutofocusables, getTopCommonParent } from './utils/parenting';\n\nvar reorderNodes = function (srcNodes, dstNodes) {\n  var remap = new Map(); // no Set(dstNodes) for IE11 :(\n\n  dstNodes.forEach(function (entity) {\n    return remap.set(entity.node, entity);\n  }); // remap to dstNodes\n\n  return srcNodes.map(function (node) {\n    return remap.get(node);\n  }).filter(isDefined);\n};\n/**\n * contains the main logic of the `focus-lock` package.\n *\n * ! you probably dont need this function !\n *\n * given top node(s) and the last active element returns the element to be focused next\n * @returns element which should be focused to move focus inside\n * @param topNode\n * @param lastNode\n */\n\n\nexport var focusSolver = function (topNode, lastNode) {\n  var activeElement = getActiveElement(asArray(topNode).length > 0 ? document : getFirst(topNode).ownerDocument);\n  var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);\n  var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries);\n  var visibilityCache = new Map();\n  var anyFocusable = getFocusableNodes(entries, visibilityCache);\n  var innerElements = anyFocusable.filter(function (_a) {\n    var node = _a.node;\n    return isNotAGuard(node);\n  });\n\n  if (!innerElements[0]) {\n    return undefined;\n  }\n\n  var outerNodes = getFocusableNodes([commonParent], visibilityCache).map(function (_a) {\n    var node = _a.node;\n    return node;\n  });\n  var orderedInnerElements = reorderNodes(outerNodes, innerElements); // collect inner focusable and separately tabbables\n\n  var innerFocusables = orderedInnerElements.map(function (_a) {\n    var node = _a.node;\n    return node;\n  });\n  var innerTabbable = orderedInnerElements.filter(function (_a) {\n    var tabIndex = _a.tabIndex;\n    return tabIndex >= 0;\n  }).map(function (_a) {\n    var node = _a.node;\n    return node;\n  });\n  var newId = newFocus(innerFocusables, innerTabbable, outerNodes, activeElement, lastNode);\n\n  if (newId === NEW_FOCUS) {\n    var focusNode = // first try only tabbable, and the fallback to all focusable, as long as at least one element should be picked for focus\n    pickAutofocus(anyFocusable, innerTabbable, allParentAutofocusables(entries, visibilityCache)) || pickAutofocus(anyFocusable, innerFocusables, allParentAutofocusables(entries, visibilityCache));\n\n    if (focusNode) {\n      return {\n        node: focusNode\n      };\n    } else {\n      console.warn('focus-lock: cannot find any node to move focus into');\n      return undefined;\n    }\n  }\n\n  if (newId === undefined) {\n    return newId;\n  }\n\n  return orderedInnerElements[newId];\n};","map":{"version":3,"names":["NEW_FOCUS","newFocus","getFocusableNodes","getAllAffectedNodes","asArray","getFirst","pickAutofocus","getActiveElement","isDefined","isNotAGuard","allParentAutofocusables","getTopCommonParent","reorderNodes","srcNodes","dstNodes","remap","Map","forEach","entity","set","node","map","get","filter","focusSolver","topNode","lastNode","activeElement","length","document","ownerDocument","entries","commonParent","visibilityCache","anyFocusable","innerElements","_a","undefined","outerNodes","orderedInnerElements","innerFocusables","innerTabbable","tabIndex","newId","focusNode","console","warn"],"sources":["/workspaces/200508238/develop/node_modules/@chakra-ui/react/node_modules/focus-lock/dist/es2015/focusSolver.js"],"sourcesContent":["import { NEW_FOCUS, newFocus } from './solver';\nimport { getFocusableNodes } from './utils/DOMutils';\nimport { getAllAffectedNodes } from './utils/all-affected';\nimport { asArray, getFirst } from './utils/array';\nimport { pickAutofocus } from './utils/auto-focus';\nimport { getActiveElement } from './utils/getActiveElement';\nimport { isDefined, isNotAGuard } from './utils/is';\nimport { allParentAutofocusables, getTopCommonParent } from './utils/parenting';\nvar reorderNodes = function (srcNodes, dstNodes) {\n    var remap = new Map();\n    // no Set(dstNodes) for IE11 :(\n    dstNodes.forEach(function (entity) { return remap.set(entity.node, entity); });\n    // remap to dstNodes\n    return srcNodes.map(function (node) { return remap.get(node); }).filter(isDefined);\n};\n/**\n * contains the main logic of the `focus-lock` package.\n *\n * ! you probably dont need this function !\n *\n * given top node(s) and the last active element returns the element to be focused next\n * @returns element which should be focused to move focus inside\n * @param topNode\n * @param lastNode\n */\nexport var focusSolver = function (topNode, lastNode) {\n    var activeElement = getActiveElement(asArray(topNode).length > 0 ? document : getFirst(topNode).ownerDocument);\n    var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);\n    var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries);\n    var visibilityCache = new Map();\n    var anyFocusable = getFocusableNodes(entries, visibilityCache);\n    var innerElements = anyFocusable.filter(function (_a) {\n        var node = _a.node;\n        return isNotAGuard(node);\n    });\n    if (!innerElements[0]) {\n        return undefined;\n    }\n    var outerNodes = getFocusableNodes([commonParent], visibilityCache).map(function (_a) {\n        var node = _a.node;\n        return node;\n    });\n    var orderedInnerElements = reorderNodes(outerNodes, innerElements);\n    // collect inner focusable and separately tabbables\n    var innerFocusables = orderedInnerElements.map(function (_a) {\n        var node = _a.node;\n        return node;\n    });\n    var innerTabbable = orderedInnerElements.filter(function (_a) {\n        var tabIndex = _a.tabIndex;\n        return tabIndex >= 0;\n    }).map(function (_a) {\n        var node = _a.node;\n        return node;\n    });\n    var newId = newFocus(innerFocusables, innerTabbable, outerNodes, activeElement, lastNode);\n    if (newId === NEW_FOCUS) {\n        var focusNode = \n        // first try only tabbable, and the fallback to all focusable, as long as at least one element should be picked for focus\n        pickAutofocus(anyFocusable, innerTabbable, allParentAutofocusables(entries, visibilityCache)) ||\n            pickAutofocus(anyFocusable, innerFocusables, allParentAutofocusables(entries, visibilityCache));\n        if (focusNode) {\n            return { node: focusNode };\n        }\n        else {\n            console.warn('focus-lock: cannot find any node to move focus into');\n            return undefined;\n        }\n    }\n    if (newId === undefined) {\n        return newId;\n    }\n    return orderedInnerElements[newId];\n};\n"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,QAApB,QAAoC,UAApC;AACA,SAASC,iBAAT,QAAkC,kBAAlC;AACA,SAASC,mBAAT,QAAoC,sBAApC;AACA,SAASC,OAAT,EAAkBC,QAAlB,QAAkC,eAAlC;AACA,SAASC,aAAT,QAA8B,oBAA9B;AACA,SAASC,gBAAT,QAAiC,0BAAjC;AACA,SAASC,SAAT,EAAoBC,WAApB,QAAuC,YAAvC;AACA,SAASC,uBAAT,EAAkCC,kBAAlC,QAA4D,mBAA5D;;AACA,IAAIC,YAAY,GAAG,UAAUC,QAAV,EAAoBC,QAApB,EAA8B;EAC7C,IAAIC,KAAK,GAAG,IAAIC,GAAJ,EAAZ,CAD6C,CAE7C;;EACAF,QAAQ,CAACG,OAAT,CAAiB,UAAUC,MAAV,EAAkB;IAAE,OAAOH,KAAK,CAACI,GAAN,CAAUD,MAAM,CAACE,IAAjB,EAAuBF,MAAvB,CAAP;EAAwC,CAA7E,EAH6C,CAI7C;;EACA,OAAOL,QAAQ,CAACQ,GAAT,CAAa,UAAUD,IAAV,EAAgB;IAAE,OAAOL,KAAK,CAACO,GAAN,CAAUF,IAAV,CAAP;EAAyB,CAAxD,EAA0DG,MAA1D,CAAiEf,SAAjE,CAAP;AACH,CAND;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,IAAIgB,WAAW,GAAG,UAAUC,OAAV,EAAmBC,QAAnB,EAA6B;EAClD,IAAIC,aAAa,GAAGpB,gBAAgB,CAACH,OAAO,CAACqB,OAAD,CAAP,CAAiBG,MAAjB,GAA0B,CAA1B,GAA8BC,QAA9B,GAAyCxB,QAAQ,CAACoB,OAAD,CAAR,CAAkBK,aAA5D,CAApC;EACA,IAAIC,OAAO,GAAG5B,mBAAmB,CAACsB,OAAD,CAAnB,CAA6BF,MAA7B,CAAoCd,WAApC,CAAd;EACA,IAAIuB,YAAY,GAAGrB,kBAAkB,CAACgB,aAAa,IAAIF,OAAlB,EAA2BA,OAA3B,EAAoCM,OAApC,CAArC;EACA,IAAIE,eAAe,GAAG,IAAIjB,GAAJ,EAAtB;EACA,IAAIkB,YAAY,GAAGhC,iBAAiB,CAAC6B,OAAD,EAAUE,eAAV,CAApC;EACA,IAAIE,aAAa,GAAGD,YAAY,CAACX,MAAb,CAAoB,UAAUa,EAAV,EAAc;IAClD,IAAIhB,IAAI,GAAGgB,EAAE,CAAChB,IAAd;IACA,OAAOX,WAAW,CAACW,IAAD,CAAlB;EACH,CAHmB,CAApB;;EAIA,IAAI,CAACe,aAAa,CAAC,CAAD,CAAlB,EAAuB;IACnB,OAAOE,SAAP;EACH;;EACD,IAAIC,UAAU,GAAGpC,iBAAiB,CAAC,CAAC8B,YAAD,CAAD,EAAiBC,eAAjB,CAAjB,CAAmDZ,GAAnD,CAAuD,UAAUe,EAAV,EAAc;IAClF,IAAIhB,IAAI,GAAGgB,EAAE,CAAChB,IAAd;IACA,OAAOA,IAAP;EACH,CAHgB,CAAjB;EAIA,IAAImB,oBAAoB,GAAG3B,YAAY,CAAC0B,UAAD,EAAaH,aAAb,CAAvC,CAjBkD,CAkBlD;;EACA,IAAIK,eAAe,GAAGD,oBAAoB,CAAClB,GAArB,CAAyB,UAAUe,EAAV,EAAc;IACzD,IAAIhB,IAAI,GAAGgB,EAAE,CAAChB,IAAd;IACA,OAAOA,IAAP;EACH,CAHqB,CAAtB;EAIA,IAAIqB,aAAa,GAAGF,oBAAoB,CAAChB,MAArB,CAA4B,UAAUa,EAAV,EAAc;IAC1D,IAAIM,QAAQ,GAAGN,EAAE,CAACM,QAAlB;IACA,OAAOA,QAAQ,IAAI,CAAnB;EACH,CAHmB,EAGjBrB,GAHiB,CAGb,UAAUe,EAAV,EAAc;IACjB,IAAIhB,IAAI,GAAGgB,EAAE,CAAChB,IAAd;IACA,OAAOA,IAAP;EACH,CANmB,CAApB;EAOA,IAAIuB,KAAK,GAAG1C,QAAQ,CAACuC,eAAD,EAAkBC,aAAlB,EAAiCH,UAAjC,EAA6CX,aAA7C,EAA4DD,QAA5D,CAApB;;EACA,IAAIiB,KAAK,KAAK3C,SAAd,EAAyB;IACrB,IAAI4C,SAAS,GACb;IACAtC,aAAa,CAAC4B,YAAD,EAAeO,aAAf,EAA8B/B,uBAAuB,CAACqB,OAAD,EAAUE,eAAV,CAArD,CAAb,IACI3B,aAAa,CAAC4B,YAAD,EAAeM,eAAf,EAAgC9B,uBAAuB,CAACqB,OAAD,EAAUE,eAAV,CAAvD,CAHjB;;IAIA,IAAIW,SAAJ,EAAe;MACX,OAAO;QAAExB,IAAI,EAAEwB;MAAR,CAAP;IACH,CAFD,MAGK;MACDC,OAAO,CAACC,IAAR,CAAa,qDAAb;MACA,OAAOT,SAAP;IACH;EACJ;;EACD,IAAIM,KAAK,KAAKN,SAAd,EAAyB;IACrB,OAAOM,KAAP;EACH;;EACD,OAAOJ,oBAAoB,CAACI,KAAD,CAA3B;AACH,CAhDM"},"metadata":{},"sourceType":"module"}